#!/usr/bin/env python3
"""
Simpelt s√∏gescript - kun retrieval uden LLM
"""

import weaviate
import os
from dotenv import load_dotenv
import re
import sys

# Indl√¶s milj√∏variabler
load_dotenv()
openai_api_key = os.getenv("OPENAI_API_KEY")

# Opret Weaviate klient
client = weaviate.Client(
    url="http://localhost:8080",
    additional_headers={"X-OpenAI-Api-Key": openai_api_key}
)

# Kun felter der faktisk eksisterer i databasen
ALL_FIELDS = [
    "chunk_id", "title", "text", "text_for_embedding", "type", "topic", 
    "keywords", "entities", "rule_type", "law_number", "status", 
    "note_reference_ids", "related_note_chunks", "related_paragraph_chunk_id",
    "summary", "dom_references", "date", "document_name"
]

def detect_paragraph_references(query):
    """Detekterer ¬ß-referencer i sp√∏rgsm√•l - nu ogs√• med bogstaver"""
    patterns = [
        r'¬ß\s*(\d+\s*[a-zA-Z]*)',       # ¬ß 15, ¬ß 33 A, ¬ß 15a osv.
        r'paragraf\s*(\d+\s*[a-zA-Z]*)', # paragraf 15, paragraf 33 A osv.
        r'section\s*(\d+\s*[a-zA-Z]*)',  # section 15, section 33 A osv.
        r'stk\.?\s*(\d+)',               # stk. 15 eller stk 15 (kun tal)
    ]
    
    references = []
    for pattern in patterns:
        matches = re.findall(pattern, query.lower())
        # Normaliser mellemrum og store/sm√• bogstaver
        normalized_matches = [match.strip().upper() for match in matches]
        references.extend(normalized_matches)
    
    return list(set(references))

def detect_chunk_id(query):
    """Detekterer om query er et chunk ID (UUID format)"""
    # UUID pattern: 8-4-4-4-12 tegn med bindestreger
    uuid_pattern = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'
    return bool(re.match(uuid_pattern, query.lower().strip()))

def chunk_search(chunk_id):
    """S√∏g efter specifikt chunk ID"""
    try:
        print(f"üîç S√∏ger efter chunk ID: {chunk_id}")
        
        results = client.query.get("LegalDocument", ALL_FIELDS).with_where({
            "path": ["chunk_id"],
            "operator": "Equal",
            "valueText": chunk_id.strip()
        }).do()
        
        documents = results.get('data', {}).get('Get', {}).get('LegalDocument', [])
        
        if documents:
            doc = documents[0]
            
            # Vis ogs√• relaterede dokumenter
            all_results = [doc]
            
            # Hvis det er en paragraf, hent relaterede noter
            if doc.get('type') == 'paragraf':
                related_notes = doc.get('related_note_chunks', [])
                print(f"üìù Henter {len(related_notes)} relaterede noter...")
                
                for note_id in related_notes:
                    note_results = client.query.get("LegalDocument", ALL_FIELDS).with_where({
                        "path": ["chunk_id"],
                        "operator": "Equal",
                        "valueText": note_id
                    }).do()
                    
                    note_docs = note_results.get('data', {}).get('Get', {}).get('LegalDocument', [])
                    all_results.extend(note_docs)
            
            # Hvis det er en note, hent relateret paragraf
            elif doc.get('type') == 'notes':
                para_id = doc.get('related_paragraph_chunk_id')
                if para_id:
                    print(f"üìñ Henter relateret paragraf...")
                    
                    para_results = client.query.get("LegalDocument", ALL_FIELDS).with_where({
                        "path": ["chunk_id"],
                        "operator": "Equal",
                        "valueText": para_id
                    }).do()
                    
                    para_docs = para_results.get('data', {}).get('Get', {}).get('LegalDocument', [])
                    all_results.extend(para_docs)
            
            return all_results
        
        return []
        
    except Exception as e:
        print(f"‚ùå Fejl ved chunk s√∏gning: {e}")
        return []

def paragraph_search(query, limit=5):
    """S√∏g efter specifikke paragraffer - optimeret prioritering"""
    paragraph_refs = detect_paragraph_references(query)
    
    if not paragraph_refs:
        return None
        
    print(f"üéØ Detekterede paragraffer: {', '.join([f'¬ß {ref}' for ref in paragraph_refs])}")
    
    all_results = []
    
    for paragraph_ref in paragraph_refs:
        try:
            # Prioriteret s√∏gning: mest specifikke f√∏rst
            priority_patterns = [
                f"¬ß {paragraph_ref.lower()}",        # "¬ß 33 a" - pr√¶cis topic match
                f"¬ß {paragraph_ref}",                # "¬ß 33 A" - pr√¶cis input match
                paragraph_ref.lower(),               # "33 a" - kort topic match
                paragraph_ref,                       # "33 A" - kort input match
            ]
            
            # S√∏g f√∏rst efter h√∏j-prioritets matches
            for search_pattern in priority_patterns:
                # S√∏g i topic f√∏rst (h√∏jest relevans for paragraffer)
                topic_where = {
                    "operator": "And",
                    "operands": [
                        {
                            "path": ["topic"],
                            "operator": "Like",
                            "valueText": f"*{search_pattern}*"
                        },
                        {
                            "path": ["type"],
                            "operator": "Equal",
                            "valueText": "paragraf"
                        }
                    ]
                }
                
                topic_results = client.query.get("LegalDocument", ALL_FIELDS).with_where(topic_where).with_limit(5).do()
                topic_documents = topic_results.get('data', {}).get('Get', {}).get('LegalDocument', [])
                
                # Tilf√∏j topic resultater f√∏rst (h√∏jest relevans)
                for doc in topic_documents:
                    if not any(existing['chunk_id'] == doc['chunk_id'] for existing in all_results):
                        all_results.append(doc)
                        
                        # Hent relaterede noter
                        related_notes = doc.get('related_note_chunks', [])
                        for note_id in related_notes[:1]:  # Kun 1 note per paragraf for at undg√• overload
                            note_results = client.query.get("LegalDocument", ALL_FIELDS).with_where({
                                "path": ["chunk_id"],
                                "operator": "Equal",
                                "valueText": note_id
                            }).do()
                            
                            note_docs = note_results.get('data', {}).get('Get', {}).get('LegalDocument', [])
                            for note_doc in note_docs:
                                if not any(existing['chunk_id'] == note_doc['chunk_id'] for existing in all_results):
                                    all_results.append(note_doc)
                
                # Stop hvis vi har nok gode topic resultater
                if len(all_results) >= limit:
                    break
            
            # Kun s√∏g i tekst hvis vi mangler resultater
            if len(all_results) < limit:
                for search_pattern in priority_patterns:
                    text_where = {
                        "operator": "And",
                        "operands": [
                            {
                                "path": ["text"],
                                "operator": "Like", 
                                "valueText": f"*{search_pattern}*"
                            },
                            {
                                "path": ["type"],
                                "operator": "Equal",
                                "valueText": "paragraf"
                            }
                        ]
                    }
                    
                    text_results = client.query.get("LegalDocument", ALL_FIELDS).with_where(text_where).with_limit(3).do()
                    text_documents = text_results.get('data', {}).get('Get', {}).get('LegalDocument', [])
                    
                    for doc in text_documents:
                        if not any(existing['chunk_id'] == doc['chunk_id'] for existing in all_results):
                            all_results.append(doc)
                    
                    # Stop hvis vi har nok resultater
                    if len(all_results) >= limit:
                        break
                    
        except Exception as e:
            print(f"‚ùå Fejl ved paragraf s√∏gning for ¬ß {paragraph_ref}: {e}")
            continue
    
    return all_results[:limit] if all_results else None

def semantic_search(query, limit=5):
    """Semantisk s√∏gning med Weaviate"""
    try:
        results = client.query.get("LegalDocument", ALL_FIELDS).with_near_text({
            "concepts": [query]
        }).with_limit(limit).do()
        
        return results.get('data', {}).get('Get', {}).get('LegalDocument', [])
    except Exception as e:
        print(f"‚ùå Fejl ved semantisk s√∏gning: {e}")
        return []

def keyword_search(query, limit=5):
    """N√∏gleordss√∏gning - bruger Like operator"""
    try:
        results = client.query.get("LegalDocument", ALL_FIELDS).with_where({
            "path": ["text"],
            "operator": "Like",  # Bruger Like i stedet for Contains
            "valueText": f"*{query}*"
        }).with_limit(limit).do()
        
        return results.get('data', {}).get('Get', {}).get('LegalDocument', [])
    except Exception as e:
        print(f"‚ùå Fejl ved n√∏gleord s√∏gning: {e}")
        return []

def print_results(results, search_type=""):
    """Print s√∏geresultater"""
    if not results:
        print("‚ùå Ingen resultater fundet")
        return
    
    print(f"\nüîç {search_type} - {len(results)} resultater:")
    print("=" * 80)
    
    for i, result in enumerate(results, 1):
        print(f"\nüìÑ RESULTAT {i}:")
        print(f"   ID: {result.get('chunk_id', 'N/A')}")
        print(f"   Type: {result.get('type', 'N/A')}")
        print(f"   Titel: {result.get('title', 'N/A')}")
        print(f"   Topic: {result.get('topic', 'N/A')}")
        print(f"   Lov: {result.get('law_number', 'N/A')}")
        print(f"   Status: {result.get('status', 'N/A')}")
        
        if result.get('keywords'):
            keywords = ', '.join(result['keywords'][:3])
            print(f"   Keywords: {keywords}")
        
        if result.get('rule_type'):
            print(f"   Rule type: {result.get('rule_type', 'N/A')}")
        
        # Vis relationer
        if result.get('related_note_chunks'):
            note_count = len(result['related_note_chunks'])
            print(f"   Relaterede noter: {note_count} stk")
        
        if result.get('related_paragraph_chunk_id'):
            print(f"   Relateret paragraf: {result['related_paragraph_chunk_id']}")
        
        text = result.get('text', '')
        if text:
            if len(text) > 200:
                print(f"   Tekst: {text[:200]}...")
            else:
                print(f"   Tekst: {text}")
        
        print("   " + "-" * 60)

def test_connection():
    """Test Weaviate forbindelse"""
    try:
        client.schema.get()
        print("‚úÖ Weaviate forbindelse OK")
        return True
    except Exception as e:
        print(f"‚ùå Weaviate fejl: {e}")
        return False

def main():
    """Hovedfunktion for interaktiv s√∏gning"""
    print("üöÄ SIMPEL S√òGNING (KUN RETRIEVAL)")
    print("=" * 50)
    
    if not test_connection():
        return
    
    if len(sys.argv) > 1:
        # Kommandolinje s√∏gning
        query = ' '.join(sys.argv[1:])
        search_query(query)
        return
    
    print("\nTilg√¶ngelige s√∏getyper:")
    print("1. Automatisk (pr√∏ver chunk ID, paragraf, derefter semantisk)")
    print("2. Kun chunk ID s√∏gning")
    print("3. Kun paragraf s√∏gning")
    print("4. Kun semantisk s√∏gning") 
    print("5. Kun n√∏gleord s√∏gning")
    print("6. Interaktiv s√∏gning")
    
    try:
        choice = input("\nV√¶lg (1-6): ").strip()
        
        if choice == "6":
            interactive_search()
        else:
            # Tilpassede prompts baseret p√• valg
            prompts = {
                "1": "Indtast s√∏geord (chunk ID, ¬ß reference eller almindeligt ord): ",
                "2": "Indtast chunk ID (UUID format): ",
                "3": "Indtast paragraf reference (f.eks. ¬ß 33 A, ¬ß 15, paragraf 8): ",
                "4": "Indtast s√∏geord for semantisk s√∏gning: ",
                "5": "Indtast n√∏gleord for teksts√∏gning: "
            }
            
            prompt = prompts.get(choice, "Indtast s√∏geord: ")
            query = input(prompt).strip()
            
            if not query:
                return
                
            if choice == "1":
                search_query(query)
            elif choice == "2":
                results = chunk_search(query)
                print_results(results, "CHUNK ID S√òGNING")
            elif choice == "3":
                results = paragraph_search(query)
                print_results(results, "PARAGRAF S√òGNING")
            elif choice == "4":
                results = semantic_search(query)
                print_results(results, "SEMANTISK S√òGNING")
            elif choice == "5":
                results = keyword_search(query)
                print_results(results, "N√òGLEORD S√òGNING")
                
    except (KeyboardInterrupt, EOFError):
        print("\nüëã Farvel!")

def search_query(query):
    """Udf√∏r s√∏gning med automatisk type detection"""
    print(f"\nüîé S√∏ger: '{query}'")
    
    # Pr√∏v chunk ID s√∏gning f√∏rst
    if detect_chunk_id(query):
        chunk_results = chunk_search(query)
        if chunk_results:
            print_results(chunk_results, "CHUNK ID S√òGNING")
            return
    
    # Pr√∏v paragraf s√∏gning
    paragraph_results = paragraph_search(query)
    if paragraph_results:
        print_results(paragraph_results, "PARAGRAF S√òGNING")
        return
    
    # Ellers semantisk s√∏gning
    semantic_results = semantic_search(query)
    if semantic_results:
        print_results(semantic_results, "SEMANTISK S√òGNING")
        return
    
    # Sidste udvej: n√∏gleord s√∏gning
    keyword_results = keyword_search(query)
    print_results(keyword_results, "N√òGLEORD S√òGNING")

def interactive_search():
    """Interaktiv s√∏gning"""
    print("\nüéØ INTERAKTIV S√òGNING")
    print("Indtast 'quit' for at afslutte")
    print("Kommandoer:")
    print("  'c:chunk-id' (chunk ID)")
    print("  'p:¬ß15' (paragraf)")
    print("  's:skattefradrag' (semantisk)")
    print("  'k:skat' (n√∏gleord)")
    print("  Eller bare indtast s√∏geord for automatisk detection")
    
    while True:
        try:
            query = input("\nüîé S√∏geord: ").strip()
            
            if query.lower() in ['quit', 'q', 'exit']:
                print("üëã Farvel!")
                break
            elif not query:
                continue
            
            # Check for kommandoer
            if query.startswith('c:'):
                results = chunk_search(query[2:])
                print_results(results, "CHUNK ID S√òGNING")
            elif query.startswith('p:'):
                results = paragraph_search(query[2:])
                print_results(results, "PARAGRAF S√òGNING")
            elif query.startswith('s:'):
                results = semantic_search(query[2:])
                print_results(results, "SEMANTISK S√òGNING")
            elif query.startswith('k:'):
                results = keyword_search(query[2:])
                print_results(results, "N√òGLEORD S√òGNING")
            else:
                # Automatisk s√∏gning
                search_query(query)
                
        except KeyboardInterrupt:
            print("\nüëã Afbrudt")
            break
        except EOFError:
            break

if __name__ == "__main__":
    main() 